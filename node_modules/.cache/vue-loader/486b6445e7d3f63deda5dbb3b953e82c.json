{"remainingRequest":"D:\\Projects\\spark\\Spark.UI\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Projects\\spark\\Spark.UI\\src\\components\\SearchBar\\Select.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Projects\\spark\\Spark.UI\\src\\components\\SearchBar\\Select.vue","mtime":1631261807257},{"path":"D:\\Projects\\spark\\Spark.UI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\Projects\\spark\\Spark.UI\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\Projects\\spark\\Spark.UI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\Projects\\spark\\Spark.UI\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\r\nexport default {\r\n  model: { event: 'change', prop: 'value' },\r\n  props: {\r\n    props: {\r\n      type: Object,\r\n      default() {\r\n        return {\r\n          // 该属性对应el-option label属性的格式化输入，类似c语言中的printf，例子如下：\r\n          // format:'{{value}}-{{label}}'  select选项格式为: 1-小明\r\n          // 其中label、value为option对象的属性名\r\n          // 请注意不支持反斜杠转义，双大括号内是属性名，不可有空格或其他字符\r\n          format: '', // format属性优先于label\r\n          value: 'value', // 该属性决定选择option对象中哪个属性作为el-option value值\r\n          label: 'label' // 该属性决定选择option对象中哪个属性作为el-option label值\r\n          // search: ['value', 'label'] // 搜索配对的属性\r\n        }\r\n      }\r\n    },\r\n    propsValue: { type: String, default: '' }, // 与props.value作用相同，但优先于其\r\n    propsLabel: { type: String, default: '' }, // 与props.value作用相同，但优先于其\r\n    disabled: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    multiple: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    placeholder: {\r\n      type: String,\r\n      default: '选择'\r\n    },\r\n    size: {\r\n      type: String,\r\n      default: 'mini'\r\n    },\r\n    value: {\r\n      type: [Array, String, Number],\r\n      default: ''\r\n    },\r\n    options: {\r\n      type: Array,\r\n      default() {\r\n        return []\r\n      }\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      keyword: ''\r\n    }\r\n  },\r\n  computed: {\r\n    opLabel() {\r\n      return this.propsLabel || this.props.label\r\n    },\r\n    opValue() {\r\n      return this.propsValue || this.props.value\r\n    },\r\n    filterOptions() {\r\n      let res = this.options\r\n      if (this.keyword) {\r\n        const options = this.options.map(option => {\r\n          let tmp = ''\r\n          const { value, label, search } = this.props\r\n          // console.log(11111, this.props)\r\n          if (Array.isArray(search) && search.length) {\r\n            tmp = search.map(k => option[k]).join('')\r\n          } else {\r\n            tmp = option[label].toString() + option[value]\r\n          }\r\n          const searchText = this.props.format ? this.formatOption(option) : tmp\r\n          return { ...option, searchText: searchText }\r\n        })\r\n        // console.log(options)\r\n        res = this.fuzzyQuery(options, this.keyword)\r\n      }\r\n      return res\r\n    },\r\n    inputVal: {\r\n      set(val) {\r\n        this.$emit('change', val)\r\n      },\r\n      get() {\r\n        return this.value\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    /**\r\n     * @description: 使用spilt方法实现模糊查询\r\n     * @param  {Array}  list     进行查询的字符串数组\r\n     * @param  {String} keyWord  查询的关键词\r\n     * @return {Array}           查询的结果\r\n     */\r\n    fuzzyQuery(list, keyWord) {\r\n      var arr = []\r\n      for (var i = 0; i < list.length; i++) {\r\n        if (list[i].searchText.split(keyWord).length > 1) {\r\n          arr.push(list[i])\r\n        }\r\n      }\r\n      return arr\r\n    },\r\n    /**\r\n     * @description:修改关键字\r\n     * @param {*} keyWord 关键字\r\n     */\r\n    filterMethod(keyword) {\r\n      this.keyword = keyword\r\n    },\r\n    /**\r\n     * @description: 格式化字符串\r\n     * @param {Object} option\r\n     * @return {String} 格式化后的字符串\r\n     */\r\n    formatOption(option) {\r\n      let formatText = this.props.format\r\n      if (formatText) {\r\n        const matchArr = [...formatText.matchAll(/{{(\\w+)}}/g)]\r\n        matchArr.forEach(item => {\r\n          const replaceText = item[0]\r\n          const optionKey = item[1]\r\n          formatText = formatText.replace(replaceText, option[optionKey])\r\n        })\r\n      } else {\r\n        const key = this.opLabel\r\n        formatText = option[key]\r\n      }\r\n      return formatText\r\n    }\r\n  }\r\n}\r\n",null]}